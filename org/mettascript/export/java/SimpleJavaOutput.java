/*
 * No copyright. No warranty. No liability accepted. Not tested.
 * Created 25/10/2014 by Zak Fenton.
 */
package org.mettascript.export.java;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.PrintStream;
import java.util.Collection;

import org.mettascript.parser.FormulaParser;
import org.mettascript.parser.Operation;

/**
 *
 * @author zak
 */
public class SimpleJavaOutput {
    PrintStream out;
    int indent;
    boolean reallyCSharp;
    
    public SimpleJavaOutput(FormulaParser document, PrintStream out, String packageName, String className, boolean reallyCSharp, boolean asExpression) throws IOException {
        this.out = out;
        this.reallyCSharp = reallyCSharp;
        
        if (asExpression) {
        	out.println("new Value() {");
        } else {
	        out.println("/* Autogenerated by the MettaScript Compiler for "
	        		+ (reallyCSharp? "C#" : "Java") + ". */");
	        out.println("/* WARNING: Java/C# output is currently broken for some examples! */");
	        out.println();
	        
	        if (reallyCSharp) {
	        	out.println("using MettaScript.Runtime;");
	        	out.println();
	        	out.println("namespace " + packageName + " {");
	        	out.println();
	        } else {
		        out.println("package " + packageName + ";");
		        out.println();
		        out.println("import org.mettascript.runtime.java.*;");
		        out.println();
	        }
	        
	        out.println("public class " + className + " "
	        		+ (reallyCSharp ? ":" : "extends") + " Value {");
        }
        
        indent++;
        
        printBody(document.getOperation());
        indent--;
        
        out.println("}");
        out.println();
        
        if (reallyCSharp && !asExpression) {
        	out.println("} // From namespace.");
        	out.println();
        }
    }
    
    private String getName(Operation nameOperation) {
        return nameOperation.token.toString();
    }
    
    private String getScopeName(Operation operation) {
    	return "_" + Math.abs(operation.findBlockBody().hashCode())%667 + "_";
    }
    
    private void printOperation(Operation operation) {
        if (operation.isConstantNumber()) {
            out.println(indent() + "new IntegerValue(\"" + operation.token.toString() + "\")");
        } else if (operation.isConstantText()) {
            out.println(indent() + "new TextValue(" + operation.token.toString() + ")");
        } else if (operation.isQuestionMark()) {
            out.println(indent() + getScopeName(operation) + "right");
        } else if (operation.isDot()) {
            out.println(indent() + getScopeName(operation) + "left");
        } else if (operation.isAnd() || operation.isOr()) {
            out.println(indent() + "(");
            indent++;
            printOperation(operation.leftHandSide);
            indent--;
            out.println(indent() + ").toBoolean() ? (");
            indent++;
            if (operation.isAnd()) {
                printOperation(operation.rightHandSide);
            } else {
                printOperation(operation.leftHandSide);
            }
            indent--;
            out.println(indent() + ") : (");
            indent++;
            if (operation.isAnd()) {
                printOperation(operation.leftHandSide);
            } else {
                printOperation(operation.rightHandSide);
            }
            indent--;
            out.println(indent() + ")");
        } else if (operation.isBlock()) {
            out.println(indent() + "new Value() {");
            indent++;
            printBody(operation.rightHandSide);
            indent--;
            out.println(indent() + "}");
        } else if (operation.isNameAlone()) {
            out.println(indent() + getName(operation));
        } else if (operation.isNothing()) {
            out.println(indent() + "Value.NOTHING");
        } else if (operation.isComma()) {
        	out.println(indent() + "new Values(");
        	indent++;
        	boolean firstMember = true;
        	for (Operation o: operation.getCommaMembers(true)) {
        		if (firstMember) {
        			firstMember = false;
        		} else {
        			out.println(indent() + ",");
        		}
        		
        		printOperation(o);
        	}
        	indent--;
        	out.println(indent() + ")");
        } else if (operation.isNormalOperation()) {
            out.println(indent() + "(");
            indent++;
            String operator;
            if (operation.leftHandSide.isNothing()) {
            	out.println(indent() + getName(operation));
            	operator = "appliedTo";
            } else {
            	printOperation(operation.leftHandSide);
            	operator = operation.operator;
            }
            indent--;
            out.println(indent() + ")._invoke(\"" + operator + "\",");
            indent++;
            printOperation(operation.rightHandSide);
            indent--;
            out.println(indent() + ")");
        }
    }
    
    private void printBody(Operation body) {
    	if (!reallyCSharp) {
        out.println(indent() + "@Override");
    	}
    	
        out.println(indent() + "public Value _invoke (Value " + getScopeName(body) + "left, "
        		+ "String " + getScopeName(body) + "op, "
        		+ "Value " + getScopeName(body) + "right) {");
        indent++;
        
        Collection<Operation> c = body.getSequenceMembers(true);
        Operation[] ops = new Operation[c.size()];
        ops = c.toArray(ops);
        for (int i = 0; i < ops.length; i++) {
        	Operation o = ops[i];
            if (i != ops.length-1 && o.isSpecialEquals()) {
                for (Operation n: o.leftHandSide.getCommaMembers(true)) {
                    out.println(indent() + "final Reference " + getName(n) + " = new Reference();");
                }
                if (o.leftHandSide.isComma()) {
                	int j = 1;
                    for (Operation n: o.leftHandSide.getCommaMembers(true)) {
                    	out.println(indent() + getName(n) + ".setValue(");
                    	indent++;
                    	out.println(indent() + "(");
                    	indent++;
                    	printOperation(o.rightHandSide);
                    	indent--;
                    	out.println(indent() + ")._invoke(\"@\", new IntegerValue(" + j + "))");
                    	indent--;
                    	out.println(indent() + ");");
                    	j++;
                    }
                } else {
                    out.println(indent() + getName(o.leftHandSide) + ".setValue(");
                    indent++;
                    printOperation(o.rightHandSide);
                    indent--;
                    out.println(indent() + ");");
                }
            } else if (i == ops.length - 1) {
                out.println(indent() + "return");
                indent++;
                printOperation(o);
                indent--;
                out.println(indent() + ";");
            } else {
            	out.println(indent() + "/* This expression is assumed to be commentary: " + o.toString() + ". */");
            }
        }
        
        indent--;
        out.println(indent() + "}");
    }
    
    private String indent() {
        String result = "";
        
        for (int i = 0; i < indent; i++) {
            result += "    ";
        }
        
        return result;
    }
}
